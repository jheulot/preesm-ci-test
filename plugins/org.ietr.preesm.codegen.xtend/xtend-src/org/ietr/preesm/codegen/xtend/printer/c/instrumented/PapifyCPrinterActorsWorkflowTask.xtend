/**
 * Copyright or © or Copr. IETR/INSA - Rennes (2017 - 2018) :
 *
 * Antoine Morvan <antoine.morvan@insa-rennes.fr> (2017 - 2018)
 * Daniel Madroñal <daniel.madronal@upm.es> (2017 - 2018)
 * Karol Desnos <karol.desnos@insa-rennes.fr> (2017)
 *
 * This software is a computer program whose purpose is to help prototyping
 * parallel applications using dataflow formalism.
 *
 * This software is governed by the CeCILL  license under French law and
 * abiding by the rules of distribution of free software.  You can  use,
 * modify and/ or redistribute the software under the terms of the CeCILL
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 *
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability.
 *
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or
 * data to be ensured and,  more generally, to use and operate it in the
 * same conditions as regards security.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL license and that you accept its terms.
 */
package org.ietr.preesm.codegen.xtend.printer.c.instrumented

import java.util.ArrayList
import java.util.Collection
import java.util.Date
import java.util.LinkedHashSet
import java.util.List
import java.util.Set
import org.ietr.preesm.codegen.xtend.model.codegen.Block
import org.ietr.preesm.codegen.xtend.model.codegen.CodeElt
import org.ietr.preesm.codegen.xtend.model.codegen.CodegenFactory
import org.ietr.preesm.codegen.xtend.model.codegen.Constant
import org.ietr.preesm.codegen.xtend.model.codegen.CoreBlock
import org.ietr.preesm.codegen.xtend.model.codegen.FunctionCall
import org.ietr.preesm.codegen.xtend.model.codegen.PortDirection
import org.ietr.preesm.codegen.xtend.printer.PrinterState
import org.ietr.preesm.codegen.xtend.printer.c.CPrinter
import org.ietr.preesm.core.scenario.papi.PapiComponent
import org.ietr.preesm.core.scenario.papi.PapiEvent
import org.ietr.preesm.core.scenario.papi.PapiEventModifier
import org.ietr.preesm.core.scenario.papi.PapifyConfig
import org.ietr.preesm.core.scenario.papi.PapifyConfigManager

/**
 * This printer currently papify C code for X86 cores..
 *
 * @author dmadronal
 */

class PapifyCPrinterActorsWorkflowTask extends CPrinter {

	new() {
		super(true)
	}
	
	/**
	 * Add a required library for Papify utilization
	 *
	 * @param blocks
	 * 			List of the Coreblocks printed by the printer
	 */
	override printCoreBlockHeader(CoreBlock block) '''
		«super.printCoreBlockHeader(block)»
		#include "eventLib.h"


	'''

	/**
	 * Configure the Papify instrumentation of each {@link Block blocks}.<br>
	 * In the current version, the instrumentation could be configured in terms of:<br>
	 * - Which cores are being monitored.<br>
	 * - Monitoring only time or time and events.<br>
	 *
	 * This configuration is based on user defined parameters within the SLAM model.<br>
	 * The results of the monitoring will be stored in a .csv file.<br>
	 *
	 * @param printerBlocks
	 * 			List of the blocks printed by the printer. (will be
	 * 			modified)
	 */
	override preProcessing(List<Block> printerBlocks, Collection<Block> allBlocks) {
		super.preProcessing(printerBlocks, allBlocks)
	}

	/**
	 * Add Papify instrumentation code in the code generation.<br>
	 * In the current version, there are three possiblities for each core instance:<br>
	 * - Monitoring timing (last parameter of the functionCall is Papified and its type is "int").<br>
	 * - Monitoring timing and events (last parameter of the functionCall is Papified and its type is "boolean").<br>
	 * - No monitoring at all.<br>
	 *
	 * The results will be written into a .csv file.<br>
	 *
	 * @param functionCall
	 * 			Funtion that is being printed
	 */
	override printFunctionCall(FunctionCall functionCall) '''
			«super.printFunctionCall(functionCall)»
	'''

	/**
	 * Almost the same main as the default CPrinter one.
	 * The only difference is the program beginning where we add Papify specific initialization (mkdir + event init).
	 */
	override String printMain(List<Block> printerBlocks) '''
			/**
			 * @file main.c
			 * @generated by «this.class.simpleName»
			 * @date «new Date»
			 *
			 */

			#define _GNU_SOURCE
			#include <unistd.h>
			#include <pthread.h>
			#include <stdio.h>

			// application dependent includes
			#include "preesm.h"
			#include "eventLib.h"

			// Declare computation thread functions
			«FOR coreBlock : printerBlocks»
			void *computationThread_Core«(coreBlock as CoreBlock).coreID»(void *arg);
			«ENDFOR»

			pthread_barrier_t iter_barrier;
			int stopThreads;

			// setting a setting core affinity
			int set_affinity_to_core(pthread_t* thread, int core_id) {
			int num_cores = sysconf(_SC_NPROCESSORS_ONLN);
			if (core_id < 0 || core_id >= num_cores)
			  printf("Wrong core number %d\n", core_id);
			  cpu_set_t cpuset;
			  CPU_ZERO(&cpuset);
			  CPU_SET(core_id, &cpuset);
			  return pthread_setaffinity_np(*thread, sizeof(cpu_set_t), &cpuset);
			}

			int main(void)
			{
			  // Papify output folder
			  mkdir("papify-output", 0777);
			  // Init Papify
			  event_init_multiplex();

			  // Declaring thread pointers
			  «FOR coreBlock : printerBlocks »
			    pthread_t threadCore«(coreBlock as CoreBlock).coreID»;
			  «ENDFOR»

			  #ifdef VERBOSE
			  printf("Launched main\n");
			  #endif

			  // Creating a synchronization barrier
			  stopThreads = 0;
			  pthread_barrier_init(&iter_barrier, NULL, «printerBlocks.size»);

			  communicationInit();

			  // Creating threads
			  «FOR coreBlock : printerBlocks»
			  pthread_create(&threadCore«(coreBlock as CoreBlock).coreID», NULL, computationThread_Core«(coreBlock as CoreBlock).coreID», NULL);
			  set_affinity_to_core(&threadCore«(coreBlock as CoreBlock).coreID»,«(coreBlock as CoreBlock).coreID»);
			  «ENDFOR»

			  // Waiting for thread terminations
			  «FOR coreBlock : printerBlocks»
			    pthread_join(threadCore«(coreBlock as CoreBlock).coreID»,NULL);
			  «ENDFOR»

			  #ifdef VERBOSE
			  printf("Press any key to stop application\n");
			  #endif

			  return 0;
			}

		'''

}
