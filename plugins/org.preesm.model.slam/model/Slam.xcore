
@GenModel(modelName="Slam", prefix="Slam", modelDirectory="/org.preesm.model.slam/ecore-gen", //	editDirectory="/org.ietr.dftools.architecture.edit/ecore-gen",
//	editorDirectory="/org.ietr.dftools.architecture.editor/ecore-gen",
//	testsDirectory="/org.ietr.dftools.architecture.tests/ecore-gen",
	// redirection="",
	// classNamePattern="",
	// codeFormatting="true",
	// cleanup="true",
	importerID="org.eclipse.emf.importer.ecore", // !! if true a instrs.ecore is generated in .impl and is used by xxpackage.init() to
	// load the intrs packages (by default this false unless the generated XyzPackage might
	// exceed Java's byte code limit of 64k)
	loadInitialization="false", creationCommands="false", creationIcons="false", dataTypeConverters="false",
	operationReflection="false", complianceLevel="8.0")
@Ecore(nsURI="http://org.preesm/model/slam")
package org.preesm.model.slam

import org.preesm.model.slam.attributes.Parameter
import org.preesm.model.slam.attributes.VLNV
import org.preesm.model.slam.component.Component
import org.preesm.model.slam.component.HierarchyPort
import org.preesm.model.slam.link.Link
import org.preesm.model.slam.utils.VLNVComparator
import org.preesm.model.slam.component.ComNode
import org.eclipse.emf.common.util.ECollections
import org.preesm.model.slam.component.Operator

// !!! This is needed as of the current versions of xcore/xtext
// For some reason when using the default String/... (i.e. without the following)
// the corresponding EPackage attributes/... are resolved to type java.lang.Object
// instead of java.lang.String.
// This causes a problem for Tom mapping generation for instance.
// The following fixes this problem.
type String wraps String

type int wraps int

type long wraps long

type double wraps double

class Design extends VLNVedElement , ParameterizedElement {
	// URL to the file where this graph is saved
	String url
	contains unordered ComponentInstance[] componentInstances keys instanceName
	contains Link[] links
	contains HierarchyPort[] hierarchyPorts
	container Component refined opposite refinements
	refers ComponentHolder componentHolder

	// COMPONENT RELATED OPERATIONS

	op Component[] getComponents() {
		if (componentHolder !== null) {
			componentHolder.components.unmodifiableView
		} else {
			ECollections.emptyEList
		}
	}
	op boolean containsComponent(VLNV name) {
		return components.exists[VLNVComparator.areSame(vlnv, name)]
	}
	op boolean containsComponent(String vlnvName) {
		return components.exists[vlnvName.equals(it.vlnv.name)]
	}
	op Component getComponent(VLNV name) {
		return components.findFirst[VLNVComparator.areSame(vlnv, name)]
	}
	op Component getComponent(String vlnvName) {
		return components.findFirst[vlnvName.equals(it.vlnv.name)]
	}

	// COMPONENT INSTANCES RELATED OPERATIONS

	op boolean containsComponentInstance(String name) {
		return componentInstances.exists[instanceName == name]
	}
	op ComponentInstance getComponentInstance(String name) {
		return componentInstances.findFirst[instanceName == name]
	}
	op ComponentInstance[] getCommunicationComponentInstances() {
		return componentInstances.filter[(it.component instanceof ComNode)].toEList.unmodifiableView
	}
	op ComponentInstance[] getOperatorComponentInstances() {
		return componentInstances.filter[(it.component instanceof Operator)].toEList.unmodifiableView
	}
	op ComponentInstance[] getComponentInstancesOfType(Component component) {
		componentInstances.filter[component.vlnv.name == it.component.vlnv.name].toEList.unmodifiableView
	}

	// LINK RELATED OPERATIONS

	op Link[] getUndirectedLinks(ComponentInstance c) {
		return links.filter [
			(!it.isDirected) && ((it.destinationComponentInstance.instanceName == c.instanceName) ||
				(it.sourceComponentInstance.instanceName == c.instanceName))
		].toEList.unmodifiableView
	}
	op Link[] getOutgoingDirectedLinks(ComponentInstance c) {
		return links.filter [
			it.isDirected && (it.sourceComponentInstance.instanceName == c.instanceName)
		].toEList.unmodifiableView
	}
	op Link[] getIncomingDirectedLinks(ComponentInstance c) {
		return links.filter [
			it.isDirected && (it.destinationComponentInstance.instanceName == c.instanceName)
		].toEList.unmodifiableView
	}
}

class ComponentInstance extends ParameterizedElement {
	refers Component component opposite instances
	String instanceName
	op boolean isHierarchical()
}

class VLNVedElement {
	contains VLNV vlnv
}

class ParameterizedElement {
	contains Parameter[] parameters
}

class ComponentHolder {
	contains unordered Component[] components
}
